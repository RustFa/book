---
title: "سوالات مصاحبه"
type: chapter
weight: 9
---

در این بخش ما یکسری سوالات مصاحبه به زبان فارسی و انگلیسی ارائه دادیم که برای یافتن ضعف‌ها کاربردی می‌باشد ([منبع سوالات](https://github.com/mrbardia72/Go-Interview-Questions-And-Answers)).


{{< details title="۱: چه تایپ‌هایی مقدار zero آن‌ها nil است؟" open=false >}}
- interfaces
- slices
- channels
- maps
- pointers
- functions
{{< /details >}}

{{< details title="۲: تایپ‌های نوع Reference؟" open=false >}}
- Pointers
- slices
- maps
- functions
- channels
{{< /details >}}

{{< details title="۳: تایپ‌های نوع Aggregate؟" open=false >}}
- Array
- structs
{{< /details >}}

{{< details title="۴: چه وقت باید از پوینتر استفاده کنیم؟" open=false >}}
**1- تابعی که یکی از پارامترهای خود را تغییر می‌دهد**  
-وقتی تابعی را فراخوانی می‌کنیم که یک پوینتر را به عنوان پارامتر می‌گیرد، انتظار داریم که متغیر ما تغییر داده شود. اگر شما متغیر را در تابع خود تغییر نمی‌دهید، پس احتمالا نباید از پوینتر استفاده کنید.

**2- عملکرد بهتر**  
-اگر رشته‌ای داشته باشید که شامل یک رمان کامل در حافظه باشد، کپی کردن این متغیر هر بار که به یک تابع جدید ارسال می‌شود، کاری بسیار گران است. ممکن است ارزشمند باشد که به جای این کار یک پوینتر را ارسال کنید، که باعث صرفه‌جویی در پردازنده و حافظه می‌شود. با این حال انجام این کار به قیمت خوانا بودن است، بنابراین فقط در صورت لزوم این بهینه‌سازی را انجام دهید.

**3- به گزینه nil نیاز دارید**  
-گاهی اوقات یک تابع باید بداند که مقدار یک چیزی چیست، همچنین باید وجود یا عدم وجود آن را بداند. معمولا هنگام خواندن JSON از این استفاده می‌کنیم تا بدانیم فیلدی وجود دارد یا خیر.
{{< /details >}}

{{< details title="۵: زبان گولنگ از موارد زیر پشتیبانی نمی‌کند؟" open=false >}}
- type inheritance
- operator overloading
- method overloading
- pointer arithmetic
- struct type in consts
{{< /details >}}

{{< details title="۶: چه موقعی از channel و چه موقعی از mutex استفاده میشه برای گوروتین‌ها؟(بحث ارتباط)؟" open=false >}}
معمولاً در مواقعی که Goroutines نیاز به برقراری ارتباط با یکدیگر دارند از channels استفاده کنید و درصورتی که فقط یک Goroutine دارید و باید به بخش مهم کد دسترسی داشته باشد از Mutexes استفاده کنید.
{{< /details >}}

{{< details title="۷: چرا کپی کردن pointer کندتر از کپی کردن مقدار است؟" open=false >}}
- برای ارسال مقادیر کوچیکی که به مقدارشون فقط نیاز داریم از پوینتر استفاده نکنیم.  
- توی متغیرهای کوچیک (کمتر از ۳۲کیلوبایت) کپی کردن یک پوینتر تقریبا به اندازه کپی کردن مقدار اون متغیر هزینه داره پس از این جهت سودی نمی‌بریم.  
- کامپایلر چک‌هایی رو تولید می‌کنه که موقع ران‌تایم زمان dereferencing پوینتر اجرا میشن.  
- پوینترها اکثرا توی Heap ذخیره میشن.  
- برای این کار از ابزار های Go استفاده می‌کنیم ( go build -gcflags="-m" main.go ). 
- اما اگر به صورت مقداری برگردونیم در stack ذخیره میشه.  
- همونطوری که می‌دونیم ذخیره در stack بسیار بهینه‌تر است.  
- درواقع Garbage collector میاد heap رو چک می‌کنه و همونطوری که میدونیم هربار GC درحال بررسی است به مدت چند میلی‌ثانیه کل سرویس ما فریز میشه. و میتونه مشکل‌هایی مثل Memory Leak و ... بوجود بیاد.
{{< /details >}}

{{< details title="Race Condition یا شرط مسابقه چیست؟" open=false >}}
- در گولنگ زمانی که دو گوروتین تلاش می‌کنند روی یک متغیر مشترک بنویسند Race Condition یا شرط مسابقه ایجاد می‌شود که نتیجه آن یک خروجی غیر منتظره است.
{{< /details >}}
  
 {{< details title="چگونه از Race Conditions یا شرط مسابقه جلوگیری کنیم؟" open=false >}}
- در گولنگ با استفاده از پکیچ sync می‌توانیم دسترسی گوروتین‌ها را به یک متغییر مدیریت کنیم.
- این مکانیسم شامل استفاده از روش‌های Lock and Unlock از پکیج sync است.
- متد Lock نشان می‌دهد که گوروتینی که این متد را فراخوانی می‌کند، به تازگی قفل را دریافت کرده است و هیچ گوروتین دیگری نمی‌تواند از قفل استفاده کند تا زمانی که آزاد شود.
- روش Unlock قفل را آزاد می‌کند تا دیگر گوروتین‌ها بتوانند از آن استفاده کنند.
- هنگامی که یک گوروتین از قفل استفاده می‌کند و دیگری سعی می‌کند قفل را نیز بدست آورد، گوروتین مسدود می‌شود تا زمانی که گوروتین دیگر قفل را آزاد کند.

{{< /details >}}

 {{< details title="چه زمانی از panci یا os.Exit استفاده کنیم؟" open=false >}}
- زمانی از panic استفاده می‌کنیم که برنامه به نقطه غیر قابل بازیابی رسیده باشد و با استفاده از panic برنامه را متوقف می‌کنیم و متن خطا را به کاربر نشان می‌دهیم. تمام توابع defer شده بعد از پنیک اجرا می‌شوند.
- برای مثال در یک برنامه در خواندن یک فایل با خطا مواجه شده‌ایم و به مقادیر فایل دسترسی نداریم در این شرایط با استفاده از panic می‌توانیم برنامه را متوقف کنیم و متن خطا را به کاربر نمایش دهیم.
- اما os.Exit زمانی استفاده می‌شود که برنامه نیاز به اتمام فوری و برگشت به سیستم عامل دارد.
- همچنین این تابع یک کد وضعیت برمیگرداند که برای سیستم عامل و برنامه‌های دیگر قابل استفاده است.
- برای مثال زمانی که در یک برنامه با سروری ارتباط داریم و ارتباط قطع می‌شود ما قادر به ادامه دادن برنامه نیستیم و می‌توانیم از این تابع استفاده کنیم.
{{< /details >}}
