---
title: '9.4.12 الگو Monitor'
slug: go-concurrency-pattern-monitor
weight: 177012
---


## 9.4.12.1 توضیحات

الگوی مانیتور به گروتین‌ ها اجازه می‌دهد هنگام ورود به حالت خواب بدون مسدود کردن اجرا یا مصرف منابع، منتظر شرایط خاصی باشند.

حال برای پیاده سازی این الگو ما از ساختاری به نام Cond در پکیج sync کمک میگیریم.

{{< hint info >}}
به نقل از ویکی پدیا :

در برنامه‌نویسی همروند (یا همان برنامه‌نویسی موازی)، **مانیتور** یک ساختار [همگام سازی](https://fa.wikipedia.org/wiki/%D9%87%D9%85%DA%AF%D8%A7%D9%85%E2%80%8C%D8%B3%D8%A7%D8%B2%DB%8C_(%D8%B9%D9%84%D9%88%D9%85_%D8%B1%D8%A7%DB%8C%D8%A7%D9%86%D9%87) "همگام‌سازی (علوم رایانه)") است که به ریسمان ها این امکان را می‌دهد که هم، [انحصار متقابل](https://fa.wikipedia.org/wiki/%D8%A7%D9%86%D8%AD%D8%B5%D8%A7%D8%B1_%D9%85%D8%AA%D9%82%D8%A7%D8%A8%D9%84 "انحصار متقابل") داشته باشند و هم، بتوانند برای یک وضعیت خاص منتظر بمانند (مسدود شوند) تا وضعیت غلط شود. مانیتورها همچنین دارای یک مکانیسم هستند که به ریسمان‌های دیگر، از طریق سیگنال می‌فهمانند که شرایط آنها برآورده شده‌است. یک مانیتور، حاوی یک شئ میوتکس (قفل) و متغیرهای وضعیت است. یک متغیر وضعیت اساساً، ظرفی از [ریسمان](https://fa.wikipedia.org/wiki/%D8%B1%DB%8C%D8%B3%D9%87_(%D8%B1%D8%A7%DB%8C%D8%A7%D9%86%D8%B4) "ریسه (رایانش)") ها است که منتظر یک وضعیت خاص هستند. مانیتورها برای ریسمان‌ها مکانیسمی را فراهم می‌کنند، تا به‌طور موقت، و با هدف منتظر ماندن برای برآورده شدن شرایط خاص، دسترسی انحصاری را رها کنند، و سپس دسترسی انحصاری را مجدداً به دست آورند و کار خود را از سر گیرند.
{{< /hint >}}

## 9.4.12.2 دیاگرام

{{<img url="#" image="../../../assets/img/content/chapter9/concurrent/4.jpg" alt="Monitor">}}

## 9.4.12.3 نمونه کد

```go
package main

import (
	"fmt"
	"sync"
)

type Item = int

type Queue struct {
	items []Item
	*sync.Cond
}

func NewQueue() *Queue {
	q := new(Queue)
	q.Cond = sync.NewCond(&sync.Mutex{})
	return q
}

func (q *Queue) Put(item Item) {
	q.L.Lock()
	defer q.L.Unlock()
	q.items = append(q.items, item)
	q.Signal()
}

func (q *Queue) GetMany(n int) []Item {
	q.L.Lock()
	defer q.L.Unlock()
	for len(q.items) < n {
		q.Wait()
	}
	items := q.items[:n:n]
	q.items = q.items[n:]
	return items
}

func main() {
	q := NewQueue()

	var wg sync.WaitGroup
	for n := 10; n > 0; n-- {
		wg.Add(1)
		go func(n int) {
			items := q.GetMany(n)
			fmt.Printf("%2d: %2d\n", n, items)
			wg.Done()
		}(n)
	}

	for i := 0; i < 100; i++ {
		q.Put(i)
	}

	wg.Wait()
}
```

```shell
$ go run main.go
 1: [ 0]
 6: [ 1  2  3  4  5  6]
 5: [ 7  8  9 10 11]
 4: [12 13 14 15]
 3: [16 17 18]
 2: [19 20]
 9: [21 22 23 24 25 26 27 28 29]
10: [30 31 32 33 34 35 36 37 38 39]
 8: [40 41 42 43 44 45 46 47]
 7: [48 49 50 51 52 53 54]
```

در کد فوق ما یک صف ساده ایجاد کردیم و این صف را با استفاده از Cond مدیریت کردیم و ۲ چیز در اینجا انجام دادیم :

- ۱۰ تا گوروتین ایجاد شد و تلاش کردند برای consume آیتم ها در یک ردیف و اگر همه آیتم ها یکبار در دسترس نباشد گوروتین ها منتظر می مانند تا زمانیکه آیتم ها افزایش یابند.
- گوروتین اصلی صفی که ایجاد کردیم با ۱۰۰ تا آیتم پر میکند و برای هر آیتمی که اضافه می شود یکی از گوروتین هایی که منتظر آیتم ها هستش را بیدار میکند تا فرآیند خود را تکمیل کند.


## 9.4.12.4 کاربردها

- **پردازش دسته‌ای:** اگر مقدار زیادی داده دارید که باید به صورت دسته‌ای پردازش شوند، می‌توانید از Cond برای سیگنال دادن به زمان آماده شدن یک دسته برای پردازش و پایان پردازش استفاده کنید.
- **انتظار برای رویدادهای خارجی:** یک Cond را می توان برای انتظار یک رویداد خارجی، مانند سیگنال از یک سرور راه دور یا تکمیل یک کار پس زمینه استفاده کرد.
- **کنترل جریان (Flow Control):** اگر چندین گوروتین دارید که باید هماهنگ شوند تا اطمینان حاصل شود که فقط تعداد معینی از گوروتین ها در یک زمان معین اجرا می شوند، می توانید از Cond برای نشان دادن زمان شروع یا توقف یک گوروتین استفاده کنید.
- **قفل کردن و باز کردن قفل منابع:** می‌توانید از یک Cond برای همگام‌سازی دسترسی به منابع مشترک با انتظار برای سیگنال قبل از دریافت قفل و علامت‌گذاری زمانی که قفل آزاد می‌شود، استفاده کنید.
- **همگام سازی چندین گوروتین:** وقتی چندین گوروتین دارید که روی یک فرآیند کار می کنند و می خواهید مطمئن شوید که همه آنها قبل از رفتن به کار بعدی تمام می شوند، می توانید از یک Cond برای علامت دادن به پایان هر گوروتین استفاده کنید و منتظر بمانید تا همه قبل از انجام کامل شوند.