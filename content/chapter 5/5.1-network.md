---
title: '5.1 شبکه چیست'
slug: network-basic
weight: 9001
---

به تجهیزات متصل یکدیگر شبکه گفته می‌شود. مکانیزم‌های اتصال ممکن است از طریق سیم مسی، اترنت، فیبر نوری یا بی‌سیم. اندازه ی شبکه می تواند به اندازه ی اینترنت بزرگ یا به اندازه ی یک شبکه خانگی کوچک باشد. یک شبکه محلی (LAN) کامپیوترهایی را که در نزدیکی یکدیگر هستند، معمولاً تعلق به یک خانه، سازمان کوچک یا قسمتی از یک سازمان بزرگ دارند، به هم متصل می‌کند.

یک شبکه گسترده (WAN) کامپیوترها را در یک منطقه فیزیکی بزرگتر، مانند بین شهرها متصل می‌کند. انواع دیگری هم وجود دارند، مانند MANs (شبکه‌های منطقه شهری)، PANs (شبکه‌های منطقه شخصی) و حتی BANs (شبکه‌های منطقه بدن).

تفاوت‌های قابل توجهی بین یک اینترنت و یک اینترانت وجود دارد. معمولاً، یک اینترانت تحت کنترل مدیریت واحد قرار خواهد گرفت و یک مجموعه یکپارچه از سیاست‌ها را اعمال خواهد کرد. از طرفی، یک اینترنت تحت کنترل یک بدنه یکپارچه نخواهد بود و کنترل‌های انجام شده بر روی بخش‌های مختلف حتی سازگاری نخواهد داشت.

## 5.1.1 چند تعریف و مفهوم کلی در شبکه

### 5.1.1.1 پروتکل
پروتکل های شبکه مجموعه قواعد و روش هایی از پیش تعریف شده برای ارتباط دو کامپیوتر در یک شبکه هستند

### 5.1.1.2 هسته (node)
هر دستگاه متصل به شبکه یک نود به حساب می آید.

### 5.1.1.3 پروتکل اینترنت IP
پروتکل اینترنت یا (internet protocol) یک ادرس منحصر بفرد برای هر دستگاه متصل به اینترنت است 
هر ایپی (v4) شامل چهار بخش یا octet است که هر بخش را عددی بین ۰ تا ۲۵۵ تشکیل می دهد


#### 5.1.1.3.1 ایپی ورژن ۶
زمان شروع و توسعه پروتکل اینترنت هر دستگاه در شبکه نیاز به یک شناسه منحصر به فرد داشت.
ایپی ورژن ۴ تنها قابلیت ایجاد 4 بیلیون شناسه یونیک را داشتند (که بنظر برای تمام دستگاه های موجود کافی و مناسب بود)
بعد از رشد چشم گیر اینترنت و دستگاه های متصل به اینترنت تعداد IP موجود حدودا کافی نبود
ایپی ورژن ۶ جدید ترین نسخه ایپی است که شمال 8 octet است و از hexadecimal استفاده میکند.
در نتیجه حدود 340 undecillion ایپی ورژن ۶ منحصر به فرد میتوان تولید کرد که برای عدد قابل توجهی دستگاه متصل به شبکه کافی است.
مثال ایپی ورژن ۶: ‍‍`2001:0db8:85a3:0000:0000:8a2e:0370:7334`

#### 5.1.1.3.2 تفاوت ها
تفاوت های IPv4 and IPv6

حافظه:
* ورژن ۴: ‍‍`32bit`
* ورژن ۶:‍‍ ‍‍`128bit`


نوع ایپی:
* ورژن ۴ : ‍‍`numeric dot-decimal`
* ورژن ۶ : `alphanumeric hexadecimal`

در نهایت گفتنی است که ورژن ۶ ایپی با استفاده از موارد امنیتی از جمله رمزنگاری و احراز هویت امنیت این پروتوکول را گسترش داده است.

<img src="https://upload.wikimedia.org/wikipedia/commons/3/39/Network_packet.jpg"></img>


## 5.1.2 لایه های پروتکل

سیستم‌های توزیع شده دشوار هستند. چندین کامپیوتر درگیر هستند که باید به یکدیگر متصل شوند. برنامه‌ها برای اجرا بر روی هر کامپیوتر در سیستم باید نوشته شوند و همه باید با همکاری یک وظیفه توزیع شده را انجام دهند. روش رایج برای مقابله با پیچیدگی، تجزیه آن به بخش‌های کوچکتر و ساده‌تر است. این بخش‌ها ساختار خود را دارند، اما همچنین وسایل مشخصی برای ارتباط با بخش‌های مرتبط دیگر دارند. در سیستم‌های توزیع شده، بخش‌ها لایه پروتکل نامیده می‌شوند و وظایف دقیقی دارند. آن‌ها یک پشته را تشکیل می‌دهند، هر لایه با لایه بالایی و پایینی خود ارتباط برقرار می‌کند. ارتباط بین لایه‌ها توسط پروتکل‌ها تعریف می‌شود. ارتباطات شبکه نیازمند پروتکل‌هایی برای پوشش ارتباطات بالارونده بین برنامه‌های کاربردی تا ارتباطات سیم و پیچیدگی‌های پروتکلی در لایه‌های پروتکلی است.


### 5.1.2.1 پروتکل ISO OSI

اگرچه هرگز به درستی پیاده‌سازی نشده است، پروتکل‌های OSI (اتصالات باز سیستم‌ها) تأثیر بزرگی در روش‌های گفتگو و طراحی سیستم‌های توزیع شده داشته‌اند. معمولاً آن‌ها به شکلی نشان داده می‌شوند که در شکل زیر نشان داده شده است.


{{<img url="#" image="../../assets/img/content/chapter5/network/1.png" alt="Protocol ISO OSI">}}


وظیفه هر لایه از پایین به بالا به شرح زیر است:

1. لایه فیزیکی با استفاده از فناوری‌های الکتریکی، نوری یا رادیویی جریان بیت را منتقل می‌کند.
2. لایه اتصال داده‌ها، بسته‌های اطلاعاتی را به فریم‌های شبکه تبدیل کرده و آن‌ها را برای انتقال از طریق لایه فیزیکی و بازگشت به بسته‌های اطلاعاتی آماده می‌کند.
3. لایه شبکه فناوری‌های سوئیچینگ و روتینگ را فراهم می‌کند.
4. لایه حمل و نقل انتقال شفاف داده بین سیستم‌های پایانی را فراهم می‌کند و مسئول بازیابی خطا در سراسر انتها به انتها و کنترل پایین است.
5. لایه جلسه، ارتباطات بین برنامه‌ها را برقرار، مدیریت و پایان می‌دهد.
6. لایه ارائه، استقلال را از تفاوت‌های در نمایش داده‌ها (مانند رمزگذاری) فراهم می‌کند.
7. لایه برنامه، پردازش‌های برنامه و کاربران پایانی را پشتیبانی می‌کند.

یک لایه در مدل OSI معمولاً با یک پروتکل مدرن نقش مشابهی دارد؛ به عنوان مثال، پروتکل IP از TCP/IP با لایه شبکه، همچنین شناخته شده به عنوان لایه 3 (لایه فیزیکی لایه 1) مرتبط است. لایه برنامه، یعنی لایه 7، با HTTP مرتبط است. برخی از پروتکل‌ها مانند HTTPS به نظر می‌رسد لایه‌ها را با هم تلفیق می‌کنند، 5 (جلسه) و 6 (ارائه). هیچ مدلی کامل نیست؛ جایگزین‌هایی برای مدل OSI وجود دارد که به واقعیت مشخصی نزدیکتر هستند، مانند مدل پروتکل TCP/IP.

### 5.1.2.2 پروتکل TCP/IP

در حالی که مدل OSI در حال بحث و جدل، پیاده‌سازی جزئی، و جنگیدن بود، پروژه تحقیقاتی DARPA در اینترنت مشغول ساخت پروتکل‌های TCP/IP بود. این پروتکل‌ها بسیار موفق بوده و منجر به ایجاد اینترنت (با حروف بزرگ) شده است. این پشته بسیار ساده‌تر است، همانطور که در شکل زیر نشان داده شده است.

{{<img url="#" image="../../assets/img/content/chapter5/network/2.png" alt="The TCP/IP protocols">}}

### 5.1.2.3 پروتکل http
پروتکل http یکی از پرکابردترین و در دسترس ترین پروتکل های دنیا است.
تا حدی که شما با یک کلیک و باز کردن مروگر خود به آن درسترسی دارید.

Http مخفف عبارت Hyper Text Transfer Protocol است که به معنی پروتکلی برای انتقال ابرمتن‌ها می‌باشد 

این پروتکل به منظور ایجاد صفحات وب انتقال ابر متن ها توسط تیم برنزلی طراحی و پیاده سازی شد.

پروتکل Http از Handshaking به منظور ارسال و دریافت اطلاعات استفاده می‌کند. در این روش برای شروع و پایان عملیات تبادل اطلاعات بین سرور و کاربر چندین درخواست و پاسخ جابه جا میشود.




## 5.1.3 دروازه (Gateways)

یک دروازه (Gateway) یک عبارت کلی برای یک جسم است که برای اتصال دو یا چند شبکه استفاده می‌شود. یک تکرار کننده (Repeater) در سطح فیزیکی عمل کرده و اطلاعات را از یک زیرشبکه به دیگری کپی می‌کند. یک پل (Bridge) در سطح لایه داده‌ای عمل می‌کند و فریم‌ها را بین شبکه‌ها کپی می‌کند. یک مسیریاب (Router) در سطح شبکه عمل می‌کند و نه تنها اطلاعات را بین شبکه‌ها منتقل می‌کند، بلکه بر روی مسیر تصمیم می‌گیرد.

دروازه یک نقطه واسط برای ارتباط بین دو شبکه است و معمولاً دروازه‌ها برای ارتباط بین شبکه‌های مختلفی با ساختار‌های مختلف استفاده می‌شوند. تکرار کننده اطلاعات را در سطح فیزیکی از یک شبکه به شبکه دیگر منتقل می‌کند. پل از طریق بررسی آدرس MAC در هر فریم، فریم‌ها را بین شبکه‌های مختلف انتقال می‌دهد. مسیریاب به عنوان یک دروازه هوشمند عمل می‌کند و برای انتقال بسته‌های داده بین شبکه‌های مختلف از پروتکل‌های مسیریابی مانند RIP، OSPF و BGP استفاده می‌کند. همچنین، مسیریاب‌ها مسیر بهینه برای انتقال بسته‌های داده را انتخاب می‌کنند و مسیریابی برای کنترل ترافیک شبکه مورد استفاده قرار می‌گیرد.

## 5.1.4 Host-Level Networking

در شبکه مبتنی بر یک میزبان، ما دارای نگرانی‌های اضافی هستیم که در طراحی، اشکال زدایی و پیاده‌سازی نرم‌افزار مبتنی بر شبکه مورد استفاده قرار می‌گیرند. برخی از این موارد عبارتند از:

- DNS (نظام نام دامنه، به عنوان نام‌گذاری سازگار با انسان)
- Firewalls (مانند مسدود کردن ترافیک ورودی یا خروجی)
- Routing (به عنوان مثال، فهمیدن کدام شبکه برای قرار دادن یک بسته مناسب است)
- مدیریت هویت میزبان (به عنوان مثال، آدرس IP)
- کنترل عملکرد (به عنوان مثال، شکل دهی و یا تلاش مجدد برای ترافیک)
- مسائل اتصال (به عنوان مثال، عدم وجود آداپتور شبکه، ارتباطات داخلی پردازش درون‌ساختمانی)

در کل، طراحی، پیاده‌سازی و مدیریت شبکه در سطح میزبان به دلیل وجود این نگرانی‌های اضافی، بسیار پیچیده تر از طراحی، پیاده‌سازی و مدیریت شبکه در سطح شبکه به شمار می‌آید.

## 5.1.5 کپسوله سازی Packet

در هرکدام از مدل OSI یا TCP/IP، ارتباط بین لایه‌ها با ارسال بسته‌های داده از یک لایه به لایه بعدی و در نهایت از طریق شبکه انجام می‌شود. هر لایه اطلاعات مدیریتی دارد که باید درباره لایه خود نگه داشته شود. برای این کار، هر لایه با اضافه کردن اطلاعات هدر به بسته‌ای که از لایه بالایی دریافت می‌کند، همانند یک لایه زیر، بسته را به لایه بعدی منتقل می‌کند. در سمت دریافت کننده، هدرهای این بسته‌ها با حرکت بسته به سمت لایه بالاتر حذف می‌شوند.  
به عنوان مثال، پروتکل انتقال پرونده‌های ساده (TFTP) فایل‌ها را از یک کامپیوتر به کامپیوتر دیگری منتقل می‌کند. این پروتکل از پروتکل UDP روی پروتکل IP استفاده می‌کند که ممکن است از طریق اترنت ارسال شود. این به صورتی است که در شکل زیر نشان داده شده است.

{{<img url="#" image="../../assets/img/content/chapter5/network/3.png" alt="The TFTP (Trivial File Transfer Protocol)">}}

## 5.1.6 مدل های ارتباط

برای دو کامپیوتر برای ارتباط با یکدیگر، آن‌ها باید یک مسیر راه‌اندازی کنند که امکان ارسال حداقل یک پیام در یک جلسه را برای آن‌ها فراهم کند. دو مدل اصلی برای این کار وجود دارد:

### 5.1.6.1 مدل مبتنی بر اتصال (Connection Oriented)
در این مدل، ابتدا یک اتصال بین دو کامپیوتر برقرار می‌شود و سپس داده‌ها در قالب یک جلسه انتقال می‌یابند. این مدل برای انتقال داده‌هایی که نیاز به اطمینان بالا و کیفیت خدمات دارند مفید است، به عنوان مثال، ارسال فایل‌های بزرگ، ارتباطات صوتی و تصویری، اتصال به اینترنت و غیره. پروتکل TCP مثالی از یک مدل مبتنی بر اتصال است.

### 5.1.6.2 مدل بدون اتصال (Connectionless)
در این مدل، هیچ اتصالی بین دو کامپیوتر برقرار نمی‌شود و هر بسته به صورت مستقل از دیگر بسته‌ها ارسال می‌شود. این مدل برای انتقال داده‌هایی که نیاز به سرعت بالا و حجم کمتری از اطلاعات دارند مفید است، به عنوان مثال، ارسال پیام‌های کوتاه، سرور های بازی، درخواست اطلاعات از یک سرور و غیره. پروتکل UDP مثالی از یک مدل بدون اتصال است.


## 5.1.7 مدل های ارتباطات

در یک سیستم توزیع‌شده، بسیاری از اجزا (یعنی فرآیندها) در حال اجرا هستند که باید با یکدیگر ارتباط برقرار کنند. دو مدل اصلی برای این کار وجود دارند: ارسال پیام و فراخوانی رویه‌های از راه دور (Remote Procedure Call).

در زمینه شبکه‌ها، این مدل‌ها اجازه ارتباط بین فرآیندها (و/یا رشته‌ها) با هدف فراخوانی رفتار روی فرآیند از راه دور را می‌دهند.

- در مدل ارسال پیام، فرآیندها با یکدیگر به صورت غیرمستقیم و از طریق ارسال پیام‌هایی که شامل داده‌های خاصی هستند، ارتباط برقرار می‌کنند. این پیام‌ها ممکن است برای انتقال داده‌ها، درخواست خدمات، یا هر نوع ارتباطی بین فرآیندها استفاده شوند. این مدل برای سیستم‌هایی که ارتباطات غیرهمزمان، توزیع شده و یا برای ارتباطاتی که نیاز به پیچیدگی بیشتری دارند، مفید است.
    
- در مدل فراخوانی رویه‌های از راه دور، فرآیند فراخواننده یک رویه محلی را فراخوانی می‌کند که در فرآیند دیگری اجرا می‌شود. در این مدل، فرآیند فراخواننده به عنوان مشتری عمل می‌کند و فرآیند دیگر به عنوان سرور. درخواست‌های مشتری به صورت پیام‌هایی به سرور فرستاده می‌شود و سرور درخواست‌ها را پردازش می‌کند و نتیجه را به مشتری می‌فرستد. این مدل برای سیستم‌هایی که نیاز به ارتباطات همزمان و یا درخواست‌هایی که نیاز به پردازش پیچیده دارند، مفید است.

### 5.1.7.1 Message Passing

بعضی زبان‌ها بر اساس اصل ارسال پیام ساخته شده‌اند. زبان‌ها و ابزارهای همزمان از این مکانیزم استفاده می‌کنند و مثال شناخته شده‌ترین آن ممکن است خط لوله UNIX باشد. خط لوله UNIX یک خط لوله از بایت‌هاست، اما این یک محدودیت ذاتی نیست: PowerShell شرکت مایکروسافت می‌تواند اشیاء را از طریق خطوط لوله خود ارسال کند و زبان‌های همزمان مانند Parlog می‌توانند ساختارهای داده منطقی دلخواه را در پیام‌های بین فرآیندهای همزمان ارسال کنند. زبان‌های جدید مانند Go دارای مکانیزم‌هایی برای ارسال پیام (بین تردها) هستند.

ارسال پیام یک مکانیزم اولیه برای سیستم‌های توزیع‌شده است. یک اتصال راه‌اندازی کرده و برخی از داده‌ها را از آن پمپ کنید. در سمت دیگر، پیام را تشخیص دهید و به آن پاسخ دهید، با احتمال ارسال پیام‌های بازگشتی. این در شکل زیر نشان داده شده است.

{{<img url="#" image="../../assets/img/content/chapter5/network/4.png" alt="The message passing communications model">}}

سیستم‌های مبتنی بر رویداد نیز به همین شکل عمل می‌کنند. در سطح پایین، زبان برنامه‌نویسی Node.js یک حلقه رویداد اجرا می‌کند که منتظر رویدادهای ورود/خروج است، برای این رویدادها شیء‌های اجرایی را فراخوانی کرده و به آن‌ها پاسخ می‌دهد. در سطح بالاتر، اکثر سیستم‌های رابط کاربری از یک حلقه رویداد برای انتظار ورودی کاربر استفاده می‌کنند، در حالی که در دنیای شبکه، Ajax از **XMLHttpRequest** برای ارسال و دریافت درخواست‌ها استفاده می‌کند.

### 5.1.7.2 Remote Procedure Call

در هر سیستمی، انتقال اطلاعات و کنترل کم از یک بخش از سیستم به بخش دیگری اتفاق می‌افتد. در زبان‌های رویه‌ای، این ممکن است شامل فراخوانی رویه باشد، که در آن اطلاعات بر روی یک پشته فراخوانی قرار داده می‌شود و سپس کنترل به بخش دیگری از برنامه منتقل می‌شود. حتی با فراخوانی رویه، تفاوت‌هایی وجود دارد. کد ممکن است به طور استاتیک متصل شود تا کنترل از قسمتی از کد اجرایی برنامه به بخش دیگری از آن منتقل شود. به دلیل استفاده روزافزون از روتین‌های کتابخانه، معمول شده است کد را در شیء‌های به اشتراک گذاشته شده (.so) یا کتابخانه‌های پیوندی پویای (.dll) داشته باشیم، که کنترل به یک قطعه کد مستقل منتقل می‌شود.

کتابخانه‌ها در همان ماشینی که کد فراخواننده در آن اجرا می‌شود، اجرا می‌شوند. این یک مرحله ساده (مفهومی) برای انتقال کنترل به یک رویه اجرا شده در ماشین دیگر (یعنی کتابخانه از راه دور) است. اما مکانیک این کار به این سادگی نیست! با این حال، این مدل کنترل باعث بروز فراخوانی رویه از راه دور (RPC) شده است که در یک فصل بعدی به طور جزئیات بیشتری بحث می‌شود. این در شکل زیر نشان داده شده است.

{{<img url="#" image="../../assets/img/content/chapter5/network/5.png" alt="The remote procedure call communications model">}}

همانطور که گفته شد، بسیاری از مثال‌هایی که وجود دارد، بر اساس زبان‌های برنامه‌نویسی خاصی مانند بسته rpc Go یا سیستم‌های RPC پوشش دهی چندین زبان مانند SOAP و gRPC شرکت گوگل است.

ممکن است مبهم باشد که چگونه ارسال پیام و RPC از هم متفاوت هستند. در یک سطح، هردو با فراخوانی رفتار "جای دیگری" مرتبط هستند. به طور کلی، RPC در مقایسه با ارسال پیام کمتر انتزاعی است (یعنی به نظر می‌رسد و به احساس فراخوانی روتین‌های معمولی شبیه است)، در حالی که در ارسال پیام ممکن است به سیستم صف‌های از راه دور فراخوانی شده باشیم. با این حال، در پشت صحنه، RPC نیز پیام‌ها را ارسال می‌کند.

### 5.1.7.3 مدل محاسبات توزیع شده (Distributed Computing)

در سطح بالاتر، می‌توانیم معادل بودن یا عدم معادل بودن اجزای یک سیستم توزیع شده را مورد بررسی قرار دهیم. شاید رایج‌ترین حالت یک حالت نامتقارن باشد: یک مشتری درخواست‌های خود را به یک سرور ارسال می‌کند و سرور پاسخ می‌دهد. این یک سیستم client-server است.

اگر هر دو اجزای سیستم معادل باشند، قادر به شروع کردن و پاسخ دادن به پیام‌ها باشند، آنگاه یک سیستم همتا به همتا داریم. توجه کنید که این یک طبقه‌بندی منطقی است: یک همتا ممکن است یک ابرکامپیوتر با ۱۶۰۰۰ هسته باشد؛ دیگری ممکن است یک تلفن همراه باشد. اما اگر هر دو می‌توانند به طور مشابه عمل کنند، آنگاه آن‌ها همتای یکدیگر هستند.

{{<img url="#" image="../../assets/img/content/chapter5/network/6.png" alt="Client-server vs. peer-to-peer systems">}}

در مثال سیستم client-server، مرورگری که با یک سرور وب صحبت می‌کند، یک مثال است. مثالی از یک سیستم همتا به همتا، سیستم پایگاه داده است که داده‌ها در آن تکثیر می‌شوند و در هر دو همتا در دسترس هستند.

ترکیب این سیستم‌ها باعث بوجود آمدن معماری‌های چند لایه می‌شود، که یکی از رایج‌ترین آن‌ها سه لایه است (یعنی ارائه -> برنامه -> داده یا مرورگر -> سرور وب -> پایگاه داده).

#### 5.1.7.3.1 سیستم client-server

به عکس زیر توجه کنید:

{{<img url="#" image="../../assets/img/content/chapter5/network/7.png" alt="The client-server system">}}

در سیستم فوق ممکن است توسط یک توسعه‌دهنده که نیاز به شناخت اجزای یک سیستم دارد، داشته باشد. همچنین، کاربری که از یک مرورگر استفاده می‌کند، می‌داند که مرورگر در سیستمش اجرا می‌شود، اما با سرورهای دیگری در جای دیگری ارتباط برقرار می‌کند.

نمودار قبلی شبیه به مدل OSI است که در ابتدای کتاب بحث شد. لایه‌های موجود در شکل فوق نیز اختیاری هستند؛ به عنوان مثال، می‌توانیم هم مشتری و هم سرور را روی یک پاره‌ای از سخت افزار نصب کنیم. قرار گرفتن روی همان ماشین به این معنی است که ما می‌توانیم برخی از لایه‌های مدل OSI را از جمله لایه ۱ (فیزیکی)، لایه ۲ (پیوند داده) و لایه ۳ (شبکه) را حذف کنیم. ما می‌گوییم "احتمالا"، زیرا این لایه‌ها هنوز ممکن است برای دلایل مختلفی از جمله همگنی ابزارها یا امنیت، مورد نیاز باشند.

#### 5.1.7.3.2 اپلیکیشن Client-Server

برخی از برنامه‌ها ممکن است به طور شفاف توزیع شده باشند، به طوری که کاربر نمی‌داند که آن توزیع شده است. کاربران دید خود را از سیستم خود مشاهده می‌کنند، همانطور که در شکل زیر نشان داده شده است.

{{<img url="#" image="../../assets/img/content/chapter5/network/8.png" alt="The user’s view of the system">}}

برای عملکرد، هر دو اجزا باید نصب شده باشند. چقدر پیچیدگی برنامه باید شفاف باشد، به برنامه و استفاده آن بستگی دارد.

#### 5.1.7.3.3 سرور توزیع شده

یک سیستم client-server نیازمند پیچیدگی نیست. مدل ابتدایی، یک سیستم مشتری-سرور تکی است که در شکل زیر نشان داده شده است.

{{<img url="#" image="../../assets/img/content/chapter5/network/9.png" alt="The single-client, single-server system">}}
  
اما می‌توانید چندین مشتری و یک سرور داشته باشید، همانطور که در شکل زیر نشان داده شده است.

{{<img url="#" image="../../assets/img/content/chapter5/network/10.png" alt="The multiple-clients, single-server system">}}

در این سیستم، مستر درخواست‌ها را دریافت کرده و به جای اینکه خودش آن‌ها را یکی یکی پردازش کند، آن‌ها را به سرورهای دیگر برای پردازش ارسال می‌کند. این یک مدل رایج است زمانی که مشتریان همزمان ممکن است وجود داشته باشند.

همچنین، می‌توانید یک مشتری و چندین سرور داشته باشید، همانطور که در شکل زیر نشان داده شده است.

{{<img url="#" image="../../assets/img/content/chapter5/network/11.png" alt="The single-client, multiple-servers system">}}

این نوع سیستم بسیار رایج است زمانی که یک سرور باید به عنوان مشتری به سرورهای دیگر عمل کند، مانند یک سرور منطق تجاری که اطلاعات را از سرور پایگاه داده دریافت می‌کند. و البته، می‌تواند چندین مشتری با چندین سرور باشد.

دوباره، این اجزا ممکن است روی یک سخت‌افزار فیزیکی قرار نگرفته باشند.

